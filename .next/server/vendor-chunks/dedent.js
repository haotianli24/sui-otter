"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dedent";
exports.ids = ["vendor-chunks/dedent"];
exports.modules = {

/***/ "(ssr)/./node_modules/dedent/dist/dedent.mjs":
/*!*********************************************!*\
  !*** ./node_modules/dedent/dist/dedent.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst dedent = createDedent({});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dedent);\nfunction createDedent(options) {\n  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));\n  return dedent;\n  function dedent(strings, ...values) {\n    const raw = typeof strings === \"string\" ? [strings] : strings.raw;\n    const {\n      alignValues = false,\n      escapeSpecialCharacters = Array.isArray(strings),\n      trimWhitespace = true\n    } = options;\n\n    // first, perform interpolation\n    let result = \"\";\n    for (let i = 0; i < raw.length; i++) {\n      let next = raw[i];\n      if (escapeSpecialCharacters) {\n        // handle escaped newlines, backticks, and interpolation characters\n        next = next.replace(/\\\\\\n[ \\t]*/g, \"\").replace(/\\\\`/g, \"`\").replace(/\\\\\\$/g, \"$\").replace(/\\\\\\{/g, \"{\");\n      }\n      result += next;\n      if (i < values.length) {\n        const value = alignValues ? alignValue(values[i], result) : values[i];\n\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        result += value;\n      }\n    }\n\n    // now strip indentation\n    const lines = result.split(\"\\n\");\n    let mindent = null;\n    for (const l of lines) {\n      const m = l.match(/^(\\s+)\\S+/);\n      if (m) {\n        const indent = m[1].length;\n        if (!mindent) {\n          // this is the first indented line\n          mindent = indent;\n        } else {\n          mindent = Math.min(mindent, indent);\n        }\n      }\n    }\n    if (mindent !== null) {\n      const m = mindent; // appease TypeScript\n      result = lines\n      // https://github.com/typescript-eslint/typescript-eslint/issues/7140\n      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n      .map(l => l[0] === \" \" || l[0] === \"\\t\" ? l.slice(m) : l).join(\"\\n\");\n    }\n\n    // dedent eats leading and trailing whitespace too\n    if (trimWhitespace) {\n      result = result.trim();\n    }\n\n    // handle escaped newlines at the end to ensure they don't get stripped too\n    if (escapeSpecialCharacters) {\n      result = result.replace(/\\\\n/g, \"\\n\");\n    }\n    return result;\n  }\n}\n\n/**\n * Adjusts the indentation of a multi-line interpolated value to match the current line.\n */\nfunction alignValue(value, precedingText) {\n  if (typeof value !== \"string\" || !value.includes(\"\\n\")) {\n    return value;\n  }\n  const currentLine = precedingText.slice(precedingText.lastIndexOf(\"\\n\") + 1);\n  const indentMatch = currentLine.match(/^(\\s+)/);\n  if (indentMatch) {\n    const indent = indentMatch[1];\n    return value.replace(/\\n/g, `\\n${indent}`);\n  }\n  return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGVkZW50L2Rpc3QvZGVkZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDO0FBQ3ZVLGlDQUFpQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELDZEQUE2RCw0Q0FBNEMsb0tBQW9LLG1GQUFtRixLQUFLO0FBQzFlLDRDQUE0QywyQkFBMkIsa0JBQWtCLGtDQUFrQyxvRUFBb0UsS0FBSyxPQUFPLG9CQUFvQjtBQUMvTiwrQkFBK0IsdUNBQXVDO0FBQ3RFLHFDQUFxQywrREFBK0Qsc0NBQXNDLDBCQUEwQiwrQ0FBK0MseUNBQXlDLHVFQUF1RTtBQUNuVSw4QkFBOEI7QUFDOUIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsTUFBTTtBQUM3RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1aS1vdHRlci8uL25vZGVfbW9kdWxlcy9kZWRlbnQvZGlzdC9kZWRlbnQubWpzP2M0ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5jb25zdCBkZWRlbnQgPSBjcmVhdGVEZWRlbnQoe30pO1xuZXhwb3J0IGRlZmF1bHQgZGVkZW50O1xuZnVuY3Rpb24gY3JlYXRlRGVkZW50KG9wdGlvbnMpIHtcbiAgZGVkZW50LndpdGhPcHRpb25zID0gbmV3T3B0aW9ucyA9PiBjcmVhdGVEZWRlbnQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwgbmV3T3B0aW9ucykpO1xuICByZXR1cm4gZGVkZW50O1xuICBmdW5jdGlvbiBkZWRlbnQoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gICAgY29uc3QgcmF3ID0gdHlwZW9mIHN0cmluZ3MgPT09IFwic3RyaW5nXCIgPyBbc3RyaW5nc10gOiBzdHJpbmdzLnJhdztcbiAgICBjb25zdCB7XG4gICAgICBhbGlnblZhbHVlcyA9IGZhbHNlLFxuICAgICAgZXNjYXBlU3BlY2lhbENoYXJhY3RlcnMgPSBBcnJheS5pc0FycmF5KHN0cmluZ3MpLFxuICAgICAgdHJpbVdoaXRlc3BhY2UgPSB0cnVlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBmaXJzdCwgcGVyZm9ybSBpbnRlcnBvbGF0aW9uXG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuZXh0ID0gcmF3W2ldO1xuICAgICAgaWYgKGVzY2FwZVNwZWNpYWxDaGFyYWN0ZXJzKSB7XG4gICAgICAgIC8vIGhhbmRsZSBlc2NhcGVkIG5ld2xpbmVzLCBiYWNrdGlja3MsIGFuZCBpbnRlcnBvbGF0aW9uIGNoYXJhY3RlcnNcbiAgICAgICAgbmV4dCA9IG5leHQucmVwbGFjZSgvXFxcXFxcblsgXFx0XSovZywgXCJcIikucmVwbGFjZSgvXFxcXGAvZywgXCJgXCIpLnJlcGxhY2UoL1xcXFxcXCQvZywgXCIkXCIpLnJlcGxhY2UoL1xcXFxcXHsvZywgXCJ7XCIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgICBpZiAoaSA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhbGlnblZhbHVlcyA/IGFsaWduVmFsdWUodmFsdWVzW2ldLCByZXN1bHQpIDogdmFsdWVzW2ldO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm93IHN0cmlwIGluZGVudGF0aW9uXG4gICAgY29uc3QgbGluZXMgPSByZXN1bHQuc3BsaXQoXCJcXG5cIik7XG4gICAgbGV0IG1pbmRlbnQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbCBvZiBsaW5lcykge1xuICAgICAgY29uc3QgbSA9IGwubWF0Y2goL14oXFxzKylcXFMrLyk7XG4gICAgICBpZiAobSkge1xuICAgICAgICBjb25zdCBpbmRlbnQgPSBtWzFdLmxlbmd0aDtcbiAgICAgICAgaWYgKCFtaW5kZW50KSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmlyc3QgaW5kZW50ZWQgbGluZVxuICAgICAgICAgIG1pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluZGVudCA9IE1hdGgubWluKG1pbmRlbnQsIGluZGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG0gPSBtaW5kZW50OyAvLyBhcHBlYXNlIFR5cGVTY3JpcHRcbiAgICAgIHJlc3VsdCA9IGxpbmVzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdHlwZXNjcmlwdC1lc2xpbnQvdHlwZXNjcmlwdC1lc2xpbnQvaXNzdWVzLzcxNDBcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXN0cmluZy1zdGFydHMtZW5kcy13aXRoXG4gICAgICAubWFwKGwgPT4gbFswXSA9PT0gXCIgXCIgfHwgbFswXSA9PT0gXCJcXHRcIiA/IGwuc2xpY2UobSkgOiBsKS5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIC8vIGRlZGVudCBlYXRzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgdG9vXG4gICAgaWYgKHRyaW1XaGl0ZXNwYWNlKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQudHJpbSgpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBlc2NhcGVkIG5ld2xpbmVzIGF0IHRoZSBlbmQgdG8gZW5zdXJlIHRoZXkgZG9uJ3QgZ2V0IHN0cmlwcGVkIHRvb1xuICAgIGlmIChlc2NhcGVTcGVjaWFsQ2hhcmFjdGVycykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xcXFxuL2csIFwiXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogQWRqdXN0cyB0aGUgaW5kZW50YXRpb24gb2YgYSBtdWx0aS1saW5lIGludGVycG9sYXRlZCB2YWx1ZSB0byBtYXRjaCB0aGUgY3VycmVudCBsaW5lLlxuICovXG5mdW5jdGlvbiBhbGlnblZhbHVlKHZhbHVlLCBwcmVjZWRpbmdUZXh0KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRMaW5lID0gcHJlY2VkaW5nVGV4dC5zbGljZShwcmVjZWRpbmdUZXh0Lmxhc3RJbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gIGNvbnN0IGluZGVudE1hdGNoID0gY3VycmVudExpbmUubWF0Y2goL14oXFxzKykvKTtcbiAgaWYgKGluZGVudE1hdGNoKSB7XG4gICAgY29uc3QgaW5kZW50ID0gaW5kZW50TWF0Y2hbMV07XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcbi9nLCBgXFxuJHtpbmRlbnR9YCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dedent/dist/dedent.mjs\n");

/***/ })

};
;